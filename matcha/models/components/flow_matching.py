from abc import ABC

import torch
import torch.nn.functional as F
from torchdiffeq import odeint, odeint_adjoint

from matcha.models.components.decoder import Decoder
from .ode_solver_wrapper import OdeSolverWrapper


class BASECFM(torch.nn.Module, ABC):
    def __init__(
        self,
        n_feats,
        cfm_params,
        n_spks=1,
        spk_emb_dim=128,
    ):
        super().__init__()
        self.n_feats = n_feats
        self.n_spks = n_spks
        self.spk_emb_dim = spk_emb_dim
        self.solver = cfm_params.solver
        if hasattr(cfm_params, "sigma_min"):
            self.sigma_min = cfm_params.sigma_min
        else:
            self.sigma_min = 1e-4

        self.estimator = None

    @torch.inference_mode()
    def forward(self, mu, mask, n_timesteps, spks=None):
        """Forward diffusion

        Args:
            mu (torch.Tensor): the mel-spectrogram generated by the encoder
                shape: (batch_size, n_feats, mel_timesteps)
            mask (torch.Tensor): Binary mask indicating valid mel frames (1) vs padding (0).
                shape: (batch_size, 1, mel_timesteps)
            n_timesteps (int): number of diffusion steps
            spks (torch.Tensor, optional): speaker ids. Defaults to None.
                shape: (batch_size, spk_emb_dim)

        Returns:
            sample: generated mel-spectrogram
                shape: (batch_size, n_feats, mel_timesteps)
        """


        # Set seed for reproducible synthesis; without this, the voice sounds slightly different 
        #  with each synthesis call so MCD metrics are not reliable.
        generator = torch.Generator(device=mu.device)
        generator.manual_seed(42)
        z = torch.randn_like(mu, generator=generator)        
        
        t_span = torch.linspace(0, 1, n_timesteps + 1, device=mu.device)
        return self.solve(z, t_span=t_span, mu=mu, mask=mask, spks=spks)

    def solve(self, x, t_span, mu, mask, spks):
        ode_func = OdeSolverWrapper(self.estimator, mask, mu, spks)
        trajectory = odeint(ode_func, x, t_span, method=self.solver)
        return trajectory[-1]

    def compute_loss(self, x1, mask, mu, spks=None):
        """Computes diffusion loss

        Args:
            x1 (torch.Tensor): Target mel-spectrogram (ground truth from training data).
                shape: (batch_size, n_feats, mel_timesteps)
            mask (torch.Tensor): Binary mask indicating valid mel frames (1) vs padding (0).
                shape: (batch_size, 1, mel_timesteps)
            mu (torch.Tensor): Encoder output - the mel-spectrogram generated by the encoder
                This serves as the conditioning signal for the flow matching process.
                shape: (batch_size, n_feats, mel_timesteps)
            spks (torch.Tensor, optional): Speaker embedding vector.
                shape: (batch_size, spk_emb_dim)

        Returns:
            loss: conditional flow matching loss (L1 distance between predicted and target flow)
            y: conditional flow - interpolated sample between noise and target at time t
                shape: (batch_size, n_feats, mel_timesteps)
        """
        b, _, t = mu.shape

        # random timestep
        t = torch.rand([b, 1, 1], device=mu.device, dtype=mu.dtype)
        # sample noise p(x_0)
        z = torch.randn_like(x1)

        # "y" is an interpolated sample between pure noise and the target spectrogram at timestep t.
        # It represents what the mel-spectrogram looks like at time t during the diffusion process.
        y = (1 - (1 - self.sigma_min) * t) * z + t * x1
        # "u" is the target velocity - the optimal direction to flow from noise to target.
        u = x1 - (1 - self.sigma_min) * z
        
        pred = self.estimator(y, mask, mu, t.squeeze(), spks)

        # I think the original loss calculation included padding, and the value from padding was huge.
        # Loss with padding: 1.355872
        # Loss properly masked: 0.052236
        # original_loss = F.mse_loss(pred, u, reduction="sum") / (torch.sum(mask) * u.shape[1])
        # Applying the mask to both the prediction and the target, ensures the loss is based only
        # on the actual speech frames and the padding does not contribute to the loss:
        loss = F.mse_loss(pred * mask, u * mask, reduction="sum") / (torch.sum(mask) * u.shape[1])
        
        return loss, y


class CFM(BASECFM):
    def __init__(self, in_channels, out_channel, cfm_params, decoder_params, n_spks=1, spk_emb_dim=64):
        super().__init__(
            n_feats=in_channels,
            cfm_params=cfm_params,
            n_spks=n_spks,
            spk_emb_dim=spk_emb_dim,
        )

        in_channels = in_channels + (spk_emb_dim if n_spks > 1 else 0)
        # Just change the architecture of the estimator here
        self.estimator = Decoder(in_channels=in_channels, out_channels=out_channel, **decoder_params)
