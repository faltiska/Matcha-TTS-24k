import math
import torch

from matcha import utils
from matcha.models.baselightningmodule import BaseLightningClass
from matcha.models.components.flow_matching import CFM
from matcha.models.components.text_encoder import TextEncoder
from matcha.utils.model import (
    denormalize,
    duration_loss,
    fix_len_compatibility,
    generate_path,
    sequence_mask,
)
from super_monotonic_align import maximum_path

log = utils.get_pylogger(__name__)

LOG_2_PI = math.log(2 * math.pi)

class MatchaTTS(BaseLightningClass):  # ðŸµ
    def __init__(
        self,
        n_vocab,
        n_spks,
        spk_emb_dim,
        n_feats,
        encoder,
        decoder,
        cfm,
        data_statistics,
        optimizer=None, # parameter required by BaseLightningClass
        scheduler=None, # parameter required by BaseLightningClass
        prior_loss=True,
        use_precomputed_durations=False,
        plot_mel_on_validation_end=False,
    ):
        super().__init__()

        self.save_hyperparameters(logger=False)

        self.n_vocab = n_vocab
        self.n_spks = n_spks
        self.spk_emb_dim = spk_emb_dim
        self.n_feats = n_feats
        self.prior_loss = prior_loss
        self.use_precomputed_durations = use_precomputed_durations
        self.plot_mel_on_validation_end = plot_mel_on_validation_end
        self.mas_const = -0.5 * LOG_2_PI * n_feats

        if n_spks > 1:
            self.spk_emb = torch.nn.Embedding(n_spks, spk_emb_dim)

        self.encoder = TextEncoder(
            encoder.encoder_type,
            encoder.encoder_params,
            encoder.duration_predictor_params,
            n_vocab,
            n_spks,
            spk_emb_dim,
        )

        self.decoder = CFM(
            in_channels=2 * encoder.encoder_params.n_feats,
            out_channel=encoder.encoder_params.n_feats,
            cfm_params=cfm,
            decoder_params=decoder,
            n_spks=n_spks,
            spk_emb_dim=spk_emb_dim,
        )

        self.update_data_statistics(data_statistics)

    def mix_speakers(self, speaker_mix):
        """Mix multiple speaker embeddings with given weights.
        
        Args:
            speaker_mix (list): List of (speaker_id, weight) tuples.
                Example: [(2, 0.7), (5, 0.3)] for 70% speaker 2 + 30% speaker 5
        
        Returns:
            torch.Tensor: Mixed speaker embedding, shape: (1, spk_emb_dim)
        """
        if self.n_spks <= 1:
            return None
        
        device = next(self.parameters()).device
        mixed_emb = None
        
        for spk_id, weight in speaker_mix:
            spk_tensor = torch.tensor([spk_id], device=device, dtype=torch.long)
            spk_emb = self.spk_emb(spk_tensor)
            
            if mixed_emb is None:
                mixed_emb = weight * spk_emb
            else:
                mixed_emb += weight * spk_emb
        
        return mixed_emb

    @torch.inference_mode()
    def synthesise(self, x, x_lengths, n_timesteps, spks=0, voice_mix=None, length_scale=1.0, variance=0.0, variance_probability=0.0):
        """
        Generates mel-spectrogram from text. Returns:
            1. encoder outputs
            2. decoder outputs
            3. generated alignment

        Args:
            x (torch.Tensor): batch of texts, converted to a tensor with phoneme embedding ids.
                shape: (batch_size, max_text_length)
            x_lengths (torch.Tensor): lengths of texts in batch.
                shape: (batch_size,)
            n_timesteps (int): number of steps to use for reverse diffusion in decoder.
            temperature (float, optional): controls variance of terminal distribution.
            spks (int, optional): speaker id (default: 0).
            voice_mix (list, optional): List of (speaker_id, weight) tuples for mixing speakers.
                Example: [(2, 0.7), (5, 0.3)] for 70% speaker 2 + 30% speaker 5
                If provided, spks parameter is ignored.
            length_scale (float, optional): controls speech pace.
                Increase value to slow down generated speech and vice versa.

        Returns:
            dict: {
                "encoder_outputs": torch.Tensor, shape: (batch_size, n_feats, max_mel_length),
                # Average mel spectrogram generated by the encoder
                "decoder_outputs": torch.Tensor, shape: (batch_size, n_feats, max_mel_length),
                # Refined mel spectrogram improved by the CFM
                "attn": torch.Tensor, shape: (batch_size, max_text_length, max_mel_length),
                # Alignment map between text and mel spectrogram
                "mel": torch.Tensor, shape: (batch_size, n_feats, max_mel_length),
                # Denormalized mel spectrogram
                "mel_lengths": torch.Tensor, shape: (batch_size,),
                # Lengths of mel spectrograms
                "rtf": float,
                # Real-time factor
            }
        """

        if self.n_spks > 1:
            if voice_mix is not None:
                spks = self.mix_speakers(voice_mix)
            else:
                device = next(self.parameters()).device
                spks = torch.tensor([spks], device=device, dtype=torch.long)
                spks = self.spk_emb(spks)

        # Get encoder_outputs `mu_x` and log-scaled token durations `logw`
        mu_x, logw, x_mask = self.encoder(x, x_lengths, spks)

        # Original code was:
        #  w = torch.exp(logw) * x_mask
        #  w_ceil = torch.ceil(w) * length_scale
        #  y_lengths = torch.clamp_min(torch.sum(w_ceil, [1, 2]), 1).long()
        # I think torch.ceil() that was rounding up each phoneme duration,
        # causing the generated speech to be consistently too slow.
        # But generate_path can handle fractional durations so I can pass w as is.
        w = torch.exp(logw) * x_mask * length_scale

        # Randomly chooses a set of phonemes (variance_probability say how many),
        # and increases their length by a factor up to variance.
        if variance > 0.0:
            mask = torch.bernoulli(torch.full_like(w, variance_probability))
            w = w * (1.0 + mask * torch.rand_like(w) * variance)

        # Ensure all durations are at least 0.5 to prevent zero-length phonemes after rounding
        # For example these durations: [1.1, 0.3, 1.8] may result in a cumsum of [1.1, 1.4, 3.2]
        # which, when rounded up will be [1, 1, 3] meaning the second phoneme will start over the first one
        w_clamped = torch.clamp_min(w.squeeze(1), 0.5)
        y_lengths = torch.clamp_min(torch.cumsum(w_clamped, 1).round()[:, -1].long(), 1)
        y_max_length = y_lengths.max()
        y_max_length_ = fix_len_compatibility(y_max_length)

        # Using obtained durations `w` construct alignment map `attn`
        y_mask = sequence_mask(y_lengths, y_max_length_).unsqueeze(1).to(x_mask.dtype)
        attn_mask = x_mask.unsqueeze(-1) * y_mask.unsqueeze(2)
        attn = generate_path(w_clamped, attn_mask.squeeze(1)).unsqueeze(1)

        # Align encoded text and get mu_y
        mu_y = mu_x @ attn.squeeze(1)
        encoder_outputs = mu_y[:, :, :y_max_length]

        # Generate sample tracing the probability flow
        decoder_outputs = self.decoder(mu_y, y_mask, n_timesteps, spks=spks)
        decoder_outputs = decoder_outputs[:, :, :y_max_length]

        return {
            "encoder_outputs": encoder_outputs,
            "decoder_outputs": decoder_outputs,
            "attn": attn[:, :, :y_max_length],
            "mel": denormalize(decoder_outputs, self.mel_mean, self.mel_std),
            "mel_lengths": y_lengths,
        }

    def forward(self, x, x_lengths, y, y_lengths, spks=None, durations=None):
        """
        Computes 3 losses:
            1. duration loss: loss between predicted token durations and those extracted by Monotonic Alignment Search (MAS).
            2. prior loss: loss between mel-spectrogram and encoder outputs.
            3. flow matching loss: loss between mel-spectrogram and decoder outputs.

        Args:
            x (torch.Tensor): batch of texts, converted to a tensor with phoneme embedding ids.
                shape: (batch_size, max_text_length)
            x_lengths (torch.Tensor): lengths of texts in batch.
                shape: (batch_size,)
            y (torch.Tensor): batch of corresponding mel-spectrograms.
                shape: (batch_size, n_feats, max_mel_length)
            y_lengths (torch.Tensor): lengths of mel-spectrograms in batch.
                shape: (batch_size,)
            spks (torch.Tensor, optional): speaker ids.
                shape: (batch_size,)
        """
        if self.n_spks > 1:
            # Get speaker embedding
            spks = self.spk_emb(spks)

        # Get encoder_outputs `mu_x` and log-scaled token durations `logw`
        mu_x, logw, x_mask = self.encoder(x, x_lengths, spks)
        y_max_length = y.shape[-1]

        y_mask = sequence_mask(y_lengths, y_max_length).unsqueeze(1).to(x_mask)
        attn_mask = x_mask.unsqueeze(-1) * y_mask.unsqueeze(2)

        if self.use_precomputed_durations:
            attn = generate_path(durations.squeeze(1), attn_mask.squeeze(1))
        else:
            # Use MAS to find most likely alignment `attn` between text and mel-spectrogram
            with torch.no_grad():
                # This computes the distance between every text token and ground truth mel frame 
                # using a  Gaussian log-likelihood formula 
                factor = -0.5 * torch.ones(mu_x.shape, dtype=mu_x.dtype, device=mu_x.device)
                y_square = torch.matmul(factor.transpose(1, 2), y ** 2)
                # Original code was:
                #   y_mu_double = torch.matmul(2.0 * (factor * mu_x).transpose(1, 2), y)
                # But (2.0 * factor * mu_x) is useless, because factor = -0.5 * tensor.ones
                # I've replaced it with just -mu_x
                y_mu_double = torch.matmul(-mu_x.transpose(1, 2), y)
                mu_square = torch.sum(factor * (mu_x ** 2), 1).unsqueeze(-1)
                log_prior = y_square - y_mu_double + mu_square + self.mas_const

                # Alternative: this computes pairwise distance between every text token and ground truth mel frame
                # Using L1-based MAS scoring would match the L1 formula I use for prior loss
                # log_prior = -torch.cdist(mu_x.transpose(1, 2), y.transpose(1, 2), p=1)

                # the GPU impl is about 5% faster, but triggers more model recompilations.
                attn = maximum_path(log_prior, attn_mask.squeeze(1).to(torch.int32), log_prior.dtype)
                # attn = monotonic_align.maximum_path_cpu(log_prior, attn_mask.squeeze(1))

        # torch.sum(attn.unsqueeze(1), -1)) says how many mel frames each text token aligns to
        # x_mask has 1s for valid text tokens, 0s for padding positions, to ensure loss is only calculated on 
        # valid tokens, preventing attention to padding.
        logw_ = torch.log(1e-8 + torch.sum(attn.unsqueeze(1), -1)) * x_mask
        # logw - log-scaled durations calculated by the TextEncoder's duration predictor
        # logw_ - log-scaled durations calculated the Monotonic Alignment Search algorithm. 
        dur_loss = duration_loss(logw, logw_, x_lengths)

        # Align encoded text with mel-spectrogram and get mu_y segment
        mu_y = torch.matmul(attn.squeeze(1).transpose(1, 2), mu_x.transpose(1, 2))
        mu_y = mu_y.transpose(1, 2)

        # Detach mu_y to prevent diffusion gradients from flowing back to the encoder. We do not want 
        # the Encoder to learn to produce mels that make the Decoder's job easier. We want the Encoder to learn 
        # how to produce mels that match the ground truth.
        # Diffusion still learns from the diff_loss, it is not affected by this detach.
        detached_mu_y = mu_y.detach()

        # Compute loss of the decoder
        diff_loss, _ = self.decoder.compute_loss(x1=y, mask=y_mask, mu=detached_mu_y, spks=spks)

        if self.prior_loss:
            # Original code was: 
            #   prior_loss = torch.sum(0.5 * ((y - mu_y) ** 2 + math.log(2 * math.pi)) * y_mask)
            # but I could remove the constants without affecting the meaning of the loss.
            #   prior_loss = torch.sum(((y - mu_y) ** 2) * y_mask)
            # Also, the values are too small, 0.05 the after first epoch tending to 0.0001
            # Such small gradients are not allowing the model to learn, so I am not squaring them up anymore.
            # This had a positive effect on duration estimation too, which started showing much smaller losses.  
            # Before this change, I could not get duration loss below 0.15, not even 400K steps.
            prior_loss = torch.sum(torch.abs(y - mu_y) * y_mask)
            prior_loss = prior_loss / (torch.sum(y_mask) * self.n_feats)
        else:
            prior_loss = 0

        return diff_loss, dur_loss, prior_loss
